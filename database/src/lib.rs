use futures::{Stream, StreamExt};
use std::{pin::Pin, sync::Arc};
use tokio::select;
use tokio_postgres::{
    connect, types::Json, AsyncMessage, Client, Error, GenericClient, NoTls, Statement, Transaction,
};

#[macro_use]
mod macros;
#[cfg(any(feature = "temp", test))]
mod temp;
#[cfg(test)]
mod tests;
mod util;

statements!(
    /// Documentation
    fn crate_add(name: &str) {
        "SELECT 1"
    }

    fn crate_delete(name: &str) {
        "SELECT 1"
    }

    fn crate_abc(name: &str) {
        "SELECT 1"
    }

    let crate_list = "SELECT 1";
    let crate_query = "SELECT 1";
);

#[cfg(any(feature = "migrations", test))]
refinery::embed_migrations!("migrations");

/// Database wrapper
///
/// This precompiles statements and offers wrappers for all mutations and queries. The wrappers are
/// partly automatically generated by the `statements!` macro.
#[derive(Clone, Debug)]
pub struct Database<T = Client> {
    /// Precompiled statements
    pub statements: Arc<Statements>,
    /// Connection to database
    pub connection: T,
}

impl<T: GenericClient> Database<T> {}

pub type ConnectionStream = Pin<Box<dyn Stream<Item = Result<AsyncMessage, Error>> + Send>>;

impl Database<Client> {
    /// Create new [`Database`] from Postgres [`Client`].
    ///
    /// This will prepare all of the statements that are used.
    pub async fn new(connection: Client) -> Result<Self, Error> {
        Ok(Database {
            statements: Arc::new(Statements::prepare(&connection).await?),
            connection,
        })
    }

    /// Connect to database.
    pub async fn connect(database: &str) -> Result<(Self, ConnectionStream), Error> {
        let (client, mut connection) = connect(database, NoTls).await?;
        let database = Database::new(client);
        let mut connection = Box::pin(futures::stream::poll_fn(move |cx| {
            connection.poll_message(cx)
        }));
        select! {
            database = database => Ok((database?, connection)),
            _result = connection.next() => panic!(),
        }
    }

    /// Create transaction.
    pub async fn transaction(&mut self) -> Result<Database<Transaction<'_>>, Error> {
        Ok(Database {
            statements: self.statements.clone(),
            connection: self.connection.transaction().await?,
        })
    }
}
